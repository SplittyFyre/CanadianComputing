
import java.awt.Point;
import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;
import java.util.Scanner;

class Cell {
	int i, j, dist;
	public Cell(int i, int j, int dist) {
		this.i = i;
		this.j = j;
		this.dist = dist;
	}
}

public class Main {
	
	private static char[][] grid;
	private static boolean[][] invalids, rndinvalids;
	
	
	
	private static LinkedList<Cell> queue = new LinkedList<Cell>();
	
	private static void enqueue(Cell cell) {
		queue.addLast(cell);
	}
	private static Cell dequeue() {
		return queue.removeFirst();
	}
	
	
	
	
	private static int stI, stJ;
	
	private static int n, m;
	
	private static int cnt, cnt2;
	private static boolean hasSolution = false;;
	
	private static List<Point> targets = new ArrayList<Point>();
	
	private static Point currtarget;

	public static void main(String[] args) {
	
		Scanner jin = new Scanner(System.in);
		
		n = jin.nextInt();
		m = jin.nextInt();
		// n = rows
		// m = columns (cells)
		grid = new char[n][m];
		invalids = new boolean[n][m];
		rndinvalids = new boolean[n][m];
		
		for (int i = 0; i < n; i++) {
			for (int j = 0; j < m; j++) {
				invalids[i][j] = false;
			}
		}
		
		for (int i = 0; i < n; i++) {
			String buf = jin.next();
			for (int j = 0; j < m; j++) {
				char c = buf.charAt(j);
				grid[i][j] = c;
				markInitialInvalids(c, i, j);
			}
		}
		
		markCameraRayInvalids();
		
		// EVERYTHING ABOVE THIS STILL WORKS
		
		for (int i = 0; i < targets.size(); i++) {
			System.out.println(evaluateSolution(targets.get(i)));
		}
		
		jin.close();
		
	}
	
	
	
	private static int evaluateSolution(Point target) {
		
		int i = target.x, j = target.y;
		
		// if target surrounded by walls and cameras
		if (invalids[i + 1][j] &&
			invalids[i - 1][j] &&
			invalids[i][j + 1] &&
			invalids[i][j - 1]) {
			return -1;
		}
		
		for (int a = 0; a < n; a++) {
			for (int b = 0; b < m; b++) {
				rndinvalids[a][b] = invalids[a][b];
			}
		}
		
		return bfs(stI, stJ, target);
	}
	
	
	
	private static int bfs(int startI, int startJ, Point target) {
		
		queue.clear();
		enqueue(new Cell(startI, startJ, 0));
		rndinvalids[startI][startJ] = true;
		
		while (!queue.isEmpty()) {
			
			Cell cell = dequeue();
			int i = cell.i, j = cell.j, nextDist = cell.dist + 1;
			
			// if target found
			if (i == target.x && j == target.y) {
				return cell.dist;
			}
			
			if (!rndinvalids[i + 1][j]) {
				enqueue(new Cell(i + 1, j, nextDist));
				rndinvalids[i + 1][j] = true;
			}
				
			if (!rndinvalids[i - 1][j]) {
				enqueue(new Cell(i - 1, j, nextDist));
				rndinvalids[i - 1][j] = true;
			}
			
			if (!rndinvalids[i][j + 1]) {
				enqueue(new Cell(i, j + 1, nextDist));
				rndinvalids[i][j + 1] = true;
			}
			
			if (!rndinvalids[i][j - 1]) {
				enqueue(new Cell(i, j - 1, nextDist));
				rndinvalids[i][j - 1] = true;
			}
			
		}
		
		// out of search, and no path
		return -1;
		
	}
	
	
	/*private static int evaluateSolution(Point target) {
		
		int i = target.x, j = target.y;
		
		if (invalids[i + 1][j] &&
			invalids[i - 1][j] &&
			invalids[i][j + 1] &&
			invalids[i][j - 1]) {
			return -1;
		}
		
		cnt = 0;
		cnt2 = Integer.MAX_VALUE;
		hasSolution = false;
		currtarget = target;
		rndinvalids = new boolean[n][m];
		for (int a = 0; a < n; a++) {
			for (int b = 0; b < m; b++) {
				rndinvalids[a][b] = invalids[a][b];
			}
		}
		
		
		dfs(stI, stJ);
				
		return hasSolution ? cnt2 : -1;
	}*/
	
	private static void dfs(int i, int j) {
		cnt++;
		System.out.println("dfs called " + i + " " + j + "  cnt: " + cnt);
		
		rndinvalids[i][j] = true;
		
		boolean moved = true;
		
		switch (grid[i][j]) {
		case 'U':
			i--;
			break;
		case 'D':
			i++;
			break;
		case 'L':
			j--;
			break;
		case 'R':
			j++;
			break;
		default:
			moved = false;
			break;
		}
		if (moved && rndinvalids[i][j]) {	
			cnt--;
			return;
		}
		else
			rndinvalids[i][j] = true;
		
		if (i == currtarget.x && j == currtarget.y) {
			hasSolution = true;
			// Math.min()
			if (cnt < cnt2) {
				cnt2 = cnt - 1;
			}
			// Is this necessary?
			cnt--;
			return;
		}
		
		if (!rndinvalids[i + 1][j])
			dfs(i + 1, j);
		if (!rndinvalids[i - 1][j])
			dfs(i - 1, j);
		if (!rndinvalids[i][j + 1])
			dfs(i, j + 1);
		if (!rndinvalids[i][j - 1])
			dfs(i, j - 1);
		
		cnt--;
		
		//return;
		
	}
	
	private static void markInitialInvalids(char c, int i, int j) {
		
		switch (c) {
		
		case 'W':
			invalids[i][j] = true;
			break;
			
		case '.':
			targets.add(new Point(i, j));
			break;
			
		case 'S':
			stI = i;
			stJ = j;
			break;
			
		case 'C':
			
			// mark initial invalid, do ray marking crap later after full grid assembled
			invalids[i][j] = true;
			
			break;
		
		}
		
	}
	
	
	
	private static void markCameraRayInvalids() {
		
		for (int i = 0; i < n; i++) {
			for (int j = 0; j < m; j++) {
				char c = grid[i][j];
				
				
				if (c == 'C') {
					
					for (int a = 1; ; a++) {
						if (grid[i + a][j] == '.') {
							invalids[i + a][j] = true;
						}
						else if (grid[i + a][j] == 'W') {
							// break if 'ray' blocked by wall
							break;
						}
					}
					
					for (int a = 1; ; a++) {
						if (grid[i - a][j] == '.') {
							invalids[i - a][j] = true;
						}
						else if (grid[i - a][j] == 'W') {
							// break if 'ray' blocked by wall
							break;
						}
					}
					
					for (int a = 1; ; a++) {
						if (grid[i][j + a] == '.') {
							invalids[i][j + a] = true;
						}
						else if (grid[i][j + a] == 'W') {
							// break if 'ray' blocked by wall
							break;
						}
					}
					
					for (int a = 1; ; a++) {
						if (grid[i][j - a] == '.') {
							invalids[i][j - a] = true;
						}
						else if (grid[i][j - a] == 'W') {
							// break if 'ray' blocked by wall
							break;
						}
					}
					
				}
				
			}
		}
		
	}

}
